<script src="w.js"></script>
<script src="treetexture.js"></script>
<script src="bricktexture.js"></script>
<canvas id=c width=800 height=600></canvas>
<script>

// +X = right, +Z = near, +Y = up
// -X = left, -Z = far, -Y = down
// All items fit in a 1 unit cube
// All angles are in degrees
// Coordinates of an object are at its center, ex: mario will be standing on the origin at [0, 0.5, 0]

// Keyboard inputs
onkeydown=onkeyup=e=>keys['s****lurd************************l**r************l*d***u**u'[e.which-32]]=+!!e.type[5]


// Hero
hero = {
  x: 3,
  y: 3,
  z: 3,
  
  ry: 0,
  rmodel: 0,
  rmodeltarget: 0,
  rcamera: 0,
  
  vx: 0,
  vy: 0,
  vz: 0,
  
  ax: 0,
  ay: 0,
  az: 0,
  
  grounded: 1
};

G = 0.05;

// The world map as a list of 10x10 grids.
map = {
  w: 10,
  h: 10,
  layers: [

  // Layer 0:

  '    $  '+
  '    $  '+
  '    $'+
  '    $'+
  '    $'+
  '    $'+
  '    \'\'\'\'\'\''+
  '          '+
  '          '+
  '          ',
  
  // Layer 1:

  '#########'+
  '##########'+
  '#(########'+
  '###(######'+
  '#(########'+
  '##########'+
  '#:########'+
  '#(########'+
  '#8###9*;##'+
  '###(######',

  // Layer 2:

  '##########'+
  '##########'+
  '#(########'+
  '##########'+
  '#(########'+
  '##########'+
  '##########'+
  '##########'+
  '##########'+
  '##########',

  // Layer 3:

  '##########'+
  '##########'+
  '#(########'+
  '##########'+
  '##########'+
  '##########'+
  '##########'+
  '##########'+
  '##########'+
  '##########',


  ]
}

bigmap = [];

collision = (x, y, z, log, block, fine) => {
  var
  y1 = Math.floor(y),
  x1 = Math.floor(x),
  z1 = Math.floor(z);
  block = bigmap[y1]?.[z1 * map.w + x1];
  if(y < 0) return 0;
  if(!block)return y;
  if(block.type == "cube") return y1+1;
  else if(block.type == "water") return y1+1;
  else if(block.type == "slope"){
    if(block.angle == 0){ // 1 towards -z, 0 towards +z
      fine = z - z1;
      return y1+1-fine;
    }
    else if(block.angle == 2){ // 0 towards -z, 1 towards +z
      fine = z - z1;
      return y1+fine;
    }
    
    if(block.angle == 3){ // 1 towards -x, 0 towards +x
      fine = x - x1;
      return y1+1-fine;
    }
    else if(block.angle == 1){ // 0 towards -x, 1 towards +x
      fine = x - x1;
      return y1+fine;
    }
  }
  //if(log) console.log(x, y, z, x1, y1, z1, block);
  return 0;
},


onload = () => {
  
  var code,xxx,yy,zz;
  
  // Reset keys
  keys = {u:0, l:0, r:0, d:0, s:0};
  
  // Create scene
  W.reset(c);
  W.ambient(0.7);
  W.light({x:.5,y:-.3,z:-.5});
  for(y=map.layers.length;y--;){
    bigmap[y] = [];
    for(x=map.w;x--;){
      for(z=map.h;z--;){
        bigmap[y][z*map.w+x] = {type: null }
        if(map.layers[y][x*map.w+z]){
          
          code = map.layers[y][z*map.w+x].codePointAt(0);
  
          // Chars 0-31: various pieces
          //
          //     0000000: \0  reserved
          //     0000001: ?   water
          //     0000010: ?   tree
          //     0000011: ?   fence
          //     ...
          //
          // Char 35: nothing
          //
          //     0100011: #   nothing
  
          if(code == 35) continue; // air
          
          if(code == 1){ // water
            W.cube({size:1,x:x+.5,y:y+.5,z:z+.5,b:"55F"});
            bigmap[y][z*map.w+x] = {type:"water"};
          }
          
          else if(code == 2){ // tree
            W.billboard({size:1,x:x+.5,y:y+.5,z:z+.5,t:tree});
            bigmap[y][z*map.w+x] = {type:"tree"};
          }
          
          // Chars 32-127: 0b0xxxyyzz
          //
          // - zz (bits 0-1): rotation
          //     0°
          //     90°
          //     180°
          //     270°
          //
          //  - yy (bits 2-3): texture (pick 4)
          //     sand
          //     grass
          //     rock
          //     ice
          //     brick
          //     wood
          //     ...
          //
          //  - xxx (bits 4-6): piece
          //     000-001 reserved (chars 0-31)
          //     010 cube
          //     011 slope
          //     100 45° wall
          //     101 slope corner flat
          //     110 slope corner angled
          //     111 pyramid
          
          else if(code > 31){
            zz = code & 0b11;
            yy = (code >> 2) & 0b11;
            xxx = (code >> 4) & 0b111;
            W[["","","cube", "slope","cube"][xxx]]({size:1,x:x+.5,y:y+.5,z:z+.5,b:["5B5","DD3","aaa","ddf"][yy],ry:zz*-90});
            bigmap[y][z*map.w+x] = {type:["","","cube", "slope"][xxx], angle: zz};
          }
        }
      }
    }
  }
  
  // H : hero group (moves, jumps, collides)
  W.group({n:"H",size:1,x:hero.x,y:hero.y,z:hero.z});
  
    // R: hero rotation group 
    W.group({n:"R",g:"H",size:1});
    
      // M: hero 3D model 
      W.cube({n:"M",g:"H",w:.2,h:.5,d:.2,y:.25, b:"FFO8"});
  
    // Camera
    W.camera({g:"H",z:3,y:1.3,rx:-5});
  
  W.clearColor("8Af");
  
  
  // Debug
  for(i = 10; i--;){
    for(j = 10; j--;){
      //W.sphere({x:i,z:j,y:0,size:.05,b:"000"});
      W.sphere({x:i,z:j,y:1,size:.05,b:"000"});
      //W.sphere({x:i,z:j,y:2,size:.05,b:"000"});
    }
  }
  
  W.sphere({n:"h1",x:hero.x-.2,z:hero.z-.2,y:hero.y,size:.05,b:"F00"});
  W.sphere({n:"h2",x:hero.x-.2,z:hero.z+.2,y:hero.y,size:.05,b:"F00"});
  W.sphere({n:"h3",x:hero.x+.2,z:hero.z-.2,y:hero.y,size:.05,b:"F00"});
  W.sphere({n:"h4",x:hero.x+.2,z:hero.z+.2,y:hero.y,size:.05,b:"F00"});
  W.sphere({n:"h1d",x:hero.x-.2,z:hero.z-.2,y:hero.y,size:.05,b:"00F"});
  W.sphere({n:"h2d",x:hero.x-.2,z:hero.z+.2,y:hero.y,size:.05,b:"00F"});
  W.sphere({n:"h3d",x:hero.x+.2,z:hero.z-.2,y:hero.y,size:.05,b:"00F"});
  W.sphere({n:"h4d",x:hero.x+.2,z:hero.z+.2,y:hero.y,size:.05,b:"00F"});
  W.sphere({n:"h5",x:hero.x-.2,z:hero.z-.2,y:hero.y+.5,size:.05,b:"F00"});
  W.sphere({n:"h6",x:hero.x-.2,z:hero.z+.2,y:hero.y+.5,size:.05,b:"F00"});
  W.sphere({n:"h7",x:hero.x+.2,z:hero.z-.2,y:hero.y+.5,size:.05,b:"F00"});
  W.sphere({n:"h8",x:hero.x+.2,z:hero.z+.2,y:hero.y+.5,size:.05,b:"F00"});
  
  
  // Game loop
  setInterval(()=>{
  
    // tmp
    var x, y, z, col, dx, dz, nw, ne, sw, se, lastx, lastz;
    
    // Rotate  left / right
    if(keys.r || keys.l){
      hero.rcamera += (-keys.l + keys.r) * 5;
    }
    
    // Move hero's group
    W.move({n:"R", rz: hero.rcamera});
    W.move({n:"H", x:hero.x, y: hero.y, z:hero.z, ry: hero.ry - hero.rcamera});
    
    //console.log(hero.rcamera, hero.x, hero.z);
    
    
    // Debug
    //console.log(hero, collision(hero.x-.1, hero.y, hero.z-.1));
    
    // red bottom
    W.move({n:"h1",x:hero.x-.1,z:hero.z-.1,y:hero.y});
    W.move({n:"h2",x:hero.x-.1,z:hero.z+.1,y:hero.y});
    W.move({n:"h3",x:hero.x+.1,z:hero.z-.1,y:hero.y});
    W.move({n:"h4",x:hero.x+.1,z:hero.z+.1,y:hero.y});
    
    // blue bottom
    W.move({n:"h1d",x:hero.x-.1,z:hero.z-.1,y:(collision(hero.x-.1, hero.y, hero.z-.1)||hero.y)+.01});
    W.move({n:"h2d",x:hero.x-.1,z:hero.z+.1,y:(collision(hero.x-.1, hero.y, hero.z+.1)||hero.y)+.01});
    W.move({n:"h3d",x:hero.x+.1,z:hero.z-.1,y:(collision(hero.x+.1, hero.y, hero.z-.1)||hero.y)+.01});
    W.move({n:"h4d",x:hero.x+.1,z:hero.z+.1,y:(collision(hero.x+.1, hero.y, hero.z+.1)||hero.y)+.01});
    
    // red top
    W.move({n:"h5",x:hero.x-.1,z:hero.z-.1,y:hero.y+.5});
    W.move({n:"h6",x:hero.x-.1,z:hero.z+.1,y:hero.y+.5});
    W.move({n:"h7",x:hero.x+.1,z:hero.z-.1,y:hero.y+.5});
    W.move({n:"h8",x:hero.x+.1,z:hero.z+.1,y:hero.y+.5});
    
    // bottom tests
    nw = (collision(hero.x-.15, hero.y, hero.z-.15)||hero.y)+.01;
    ne = (collision(hero.x+.15, hero.y, hero.z-.15)||hero.y)+.01;
    sw = (collision(hero.x-.15, hero.y, hero.z+.15)||hero.y)+.01;
    se = (collision(hero.x+.15, hero.y, hero.z+.15)||hero.y)+.01;
    
    // Grounded
    hero.grounded = 0;
    if(nw || ne || sw || se) {
      //console.log(nw, ne, sw, se);
      if(Math.max(nw, ne, sw, se) < hero.y + 0.1){
        hero.y = Math.max(nw, ne, sw, se);
      }
      hero.grounded = 1;
    }
    
    // Fall
    hero.vy -= G;
    if(hero.vy <= -G) hero.vy = -G;
    //console.log("fall");
    hero.y += hero.vy;
    if(hero.y < 1) hero.y = 1;
    
    lastx = hero.x;
    lastz = hero.z;
    
    
    // Go front / back
    if(keys.u || keys.d){
      dz = (-keys.u + keys.d) * Math.cos(-hero.rcamera*Math.PI/180) / 20;
    
      // Front collision
      if(dz < 0 && (nw > hero.y + .2 || ne > hero.y + .2)){
          console.log("f");
          //hero.z += .01;
      }
      
      // Back collision
      else if(dz > 0 && (sw > hero.y + .2 || se > hero.y + .2)){
          console.log("b");
          //hero.z -= .01;
      }
      else {
        hero.z += dz;
      }
      
      dx = (-keys.u + keys.d) * Math.sin(-hero.rcamera*Math.PI/180) / 20;
    
      // Left collision
      if(dx < 0 && (nw > hero.y + .2 || sw > hero.y + .2)){
          console.log("l");
          //hero.x -= .01;
      }
      
      // Right collision
      else if(dx > 0 && (ne > hero.y + .2 || se > hero.y + .2)){
          console.log("r");
          //hero.x += .01;
      }
      else {
        hero.x += dx;
      }
    }

    
    //console.log(hero.y);
    
  },16);
}
</script>